<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Capy Road - Colisão Corrigida</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Arial Black', sans-serif; background-color: #99c846; touch-action: none; }
        canvas.game { display: block; width: 100vw; height: 100vh; }
        #score-ui {
            position: absolute; top: 20px; width: 100%; text-align: center;
            font-size: 60px; font-weight: 900; color: white;
            text-shadow: 0 5px 15px rgba(0,0,0,0.3); pointer-events: none; z-index: 10;
        }
        #back-btn {
            position: absolute; top: 20px; left: 20px; padding: 12px 20px;
            background: white; border: none; border-radius: 12px;
            font-weight: bold; cursor: pointer; box-shadow: 0 4px 0 #ddd; z-index: 100;
        }
        #controls {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: grid; grid-template-columns: repeat(3, 85px); grid-template-rows: repeat(2, 85px);
            gap: 10px; z-index: 200;
        }
        .btn {
            width: 85px; height: 85px; background: rgba(0, 150, 255, 0.7);
            border: 4px solid white; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 40px; user-select: none; cursor: pointer;
        }
        .btn:active { background: #0070ff; transform: scale(0.9); }
        .up { grid-column: 2; }
        .left { grid-column: 1; grid-row: 2; }
        .down { grid-column: 2; grid-row: 2; }
        .right { grid-column: 3; grid-row: 2; }
    </style>
</head>
<body>

<button id="back-btn" onclick="window.location.href='index.html'">MENU</button>
<div id="score-ui">0</div>

<div id="controls">
    <div class="btn up" id="m-up">▲</div>
    <div class="btn left" id="m-left">◀</div>
    <div class="btn down" id="m-down">▼</div>
    <div class="btn right" id="m-right">▶</div>
</div>

<canvas class="game"></canvas>

<script type="module">
    import * as THREE from "https://esm.sh/three";

    const skinAtual = localStorage.getItem('skinAtual') || 'capy';
    const tileSize = 42;
    const minTile = -6;
    const maxTile = 6;
    let isGameOver = false, metadata = [], score = 0;
    let position = { row: 0, tile: 0 };
    let movesQueue = [];

    const scene = new THREE.Scene();
    const map = new THREE.Group(); scene.add(map);
    const player = new THREE.Group(); scene.add(player);

    const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector(".game"), antialias: true });
    renderer.shadowMap.enabled = true;
    renderer.setClearColor(0x99c846);

    const camera = new THREE.OrthographicCamera();
    camera.up.set(0, 0, 1);
    camera.position.set(300, -300, 300);

    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
    dirLight.position.set(-100, -200, 300);
    dirLight.castShadow = true;
    scene.add(dirLight);

    function resize() {
        const r = window.innerWidth / window.innerHeight;
        const s = 150;
        camera.left = -s * r; camera.right = s * r;
        camera.top = s; camera.bottom = -s;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', resize); resize();

    function buildPlayer() {
        player.clear();
        const g = new THREE.Group();
        const eyeMat = new THREE.MeshLambertMaterial({color: 0x000000});
        const eyeGeo = new THREE.BoxGeometry(2, 2, 2);

        if(skinAtual === 'capy') {
            const mat = new THREE.MeshLambertMaterial({color: 0x795548});
            const body = new THREE.Mesh(new THREE.BoxGeometry(22, 34, 18), mat);
            body.position.z = 15; body.castShadow = true; g.add(body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(16, 14, 14), mat);
            head.position.set(0, 18, 22); g.add(head);
            const snout = new THREE.Mesh(new THREE.BoxGeometry(16, 10, 10), new THREE.MeshLambertMaterial({color: 0x4e342e}));
            snout.position.set(0, 24, 20); g.add(snout);
            const eL = new THREE.Mesh(eyeGeo, eyeMat); eL.position.set(8.5, 20, 24); g.add(eL);
            const eR = eL.clone(); eR.position.x = -8.5; g.add(eR);
        } else if(skinAtual === 'dino') {
            const mat = new THREE.MeshLambertMaterial({color: 0x388E3C});
            const body = new THREE.Mesh(new THREE.BoxGeometry(18, 22, 26), mat);
            body.position.z = 15; body.castShadow = true; g.add(body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(14, 24, 14), mat);
            head.position.set(0, 10, 32); g.add(head);
        } else if(skinAtual === 'pingu') {
            const mat = new THREE.MeshLambertMaterial({color: 0x212121});
            const body = new THREE.Mesh(new THREE.BoxGeometry(22, 22, 28), mat);
            body.position.z = 14; body.castShadow = true; g.add(body);
            const belly = new THREE.Mesh(new THREE.BoxGeometry(16, 4, 20), new THREE.MeshLambertMaterial({color: 0xffffff}));
            belly.position.set(0, 10, 12); g.add(belly);
        }

        const legGeo = new THREE.BoxGeometry(6, 6, 8);
        const legMat = new THREE.MeshLambertMaterial({color: 0x333333});
        [[-7, 12], [7, 12], [-7, -12], [7, -12]].forEach(p => {
            const leg = new THREE.Mesh(legGeo, legMat);
            leg.position.set(p[0], p[1], 4); g.add(leg);
        });
        player.add(g);
    }

    function createRealisticCar(dir) {
        const car = new THREE.Group();
        const colors = [0xff4757, 0x1e90ff, 0x2ed573, 0xffa502, 0x5352ed];
        const mainColor = colors[Math.floor(Math.random() * colors.length)];
        const body = new THREE.Mesh(new THREE.BoxGeometry(65, 30, 14), new THREE.MeshLambertMaterial({ color: mainColor }));
        body.position.z = 10; body.castShadow = true; car.add(body);
        const cabin = new THREE.Mesh(new THREE.BoxGeometry(38, 26, 12), new THREE.MeshLambertMaterial({ color: mainColor }));
        cabin.position.set(-5, 0, 22); car.add(cabin);
        const wheelGeo = new THREE.BoxGeometry(12, 6, 12);
        const wheelMat = new THREE.MeshLambertMaterial({ color: 0x2d3436 });
        [[-20, 15], [-20, -15], [20, 15], [20, -15]].forEach(p => {
            const w = new THREE.Mesh(wheelGeo, wheelMat);
            w.position.set(p[0], p[1], 6); car.add(w);
        });
        if(!dir) car.rotation.z = Math.PI;
        return car;
    }

    function createTree(tile) {
        const group = new THREE.Group(); group.position.x = tile * tileSize;
        const trunk = new THREE.Mesh(new THREE.BoxGeometry(12, 12, 20), new THREE.MeshLambertMaterial({ color: 0x4d2926 }));
        trunk.position.z = 10; group.add(trunk);
        const crown = new THREE.Mesh(new THREE.BoxGeometry(30, 30, 35), new THREE.MeshLambertMaterial({ color: 0x2ecc71 }));
        crown.position.z = 35; crown.castShadow = true; group.add(crown);
        return group;
    }

    function addRows(n) {
        for(let i=0; i<n; i++) {
            const rowIdx = metadata.length + 1;
            const isRoad = Math.random() > 0.5;
            const row = new THREE.Group(); row.position.y = rowIdx * tileSize;
            let data = { type: isRoad?"road":"grass", vehicles: [], trees: [] };
            if(isRoad) {
                const r = new THREE.Mesh(new THREE.PlaneGeometry(1200, tileSize), new THREE.MeshLambertMaterial({color:0x454a59}));
                r.receiveShadow = true; row.add(r);
                data.dir = Math.random() > 0.5; data.speed = 130 + Math.random()*100;
                const v = createRealisticCar(data.dir); row.add(v); data.vehicles.push({ ref: v });
            } else {
                const g = new THREE.Mesh(new THREE.BoxGeometry(1200, tileSize, 2), new THREE.MeshLambertMaterial({color:0xbaf455}));
                g.receiveShadow = true; row.add(g);
                for(let t=0; t<2; t++) {
                    const tIdx = Math.floor(Math.random()*(maxTile-minTile)) + minTile;
                    if(tIdx !== 0 || rowIdx > 3) { 
                        const tree = createTree(tIdx); row.add(tree); data.trees.push(tIdx); 
                    }
                }
            }
            metadata.push(data); map.add(row);
        }
    }

    function move(d) {
        if(isGameOver || movesQueue.length > 0) return;
        let tRow = position.row + (d==="forward"?1:d==="backward"?-1:0);
        let tTile = position.tile + (d==="right"?1:d==="left"?-1:0);
        if(tRow < 0 || tTile < minTile || tTile > maxTile) return;
        if(metadata[tRow-1]?.type === "grass" && metadata[tRow-1].trees.includes(tTile)) return;
        
        if(d === "forward") player.rotation.z = 0;
        if(d === "backward") player.rotation.z = Math.PI;
        if(d === "left") player.rotation.z = Math.PI / 2;
        if(d === "right") player.rotation.z = -Math.PI / 2;

        movesQueue.push({ dir: d, tX: tTile * tileSize, tY: tRow * tileSize, progress: 0 });
    }

    function animate() {
        requestAnimationFrame(animate);
        if(!isGameOver) {
            metadata.forEach((r, idx) => {
                const rowY = (idx + 1) * tileSize;
                r.vehicles?.forEach(v => {
                    v.ref.position.x += (r.dir?1:-1) * r.speed * 0.016;
                    if(v.ref.position.x > 550) v.ref.position.x = -550;
                    if(v.ref.position.x < -550) v.ref.position.x = 550;

                    // --- COLISÃO RIGOROSA ---
                    const dx = Math.abs(v.ref.position.x - player.position.x);
                    const dy = Math.abs(rowY - player.position.y);
                    if(dx < 45 && dy < 20) {
                        isGameOver = true; 
                        setTimeout(() => window.location.reload(), 500);
                    }
                });
            });

            if(movesQueue.length > 0) {
                const m = movesQueue[0]; m.progress += 0.25;
                player.position.x = THREE.MathUtils.lerp(position.tile * tileSize, m.tX, m.progress);
                player.position.y = THREE.MathUtils.lerp(position.row * tileSize, m.tY, m.progress);
                player.position.z = Math.sin(m.progress * Math.PI) * 18;
                if(m.progress >= 1) {
                    player.position.set(m.tX, m.tY, 0); player.position.z = 0;
                    position.row += (m.dir==="forward"?1:m.dir==="backward"?-1:0);
                    position.tile += (m.dir==="right"?1:m.dir==="left"?-1:0);
                    movesQueue.shift(); score = position.row;
                    document.getElementById('score-ui').innerText = score;
                    if(position.row > metadata.length - 15) addRows(10);
                }
            }
        }
        camera.position.y = player.position.y - 250; camera.position.x = player.position.x + 250;
        camera.lookAt(player.position.x, player.position.y, 0); renderer.render(scene, camera);
    }

    window.onkeydown = (e) => {
        const k = { ArrowUp:"forward", ArrowDown:"backward", ArrowLeft:"left", ArrowRight:"right" };
        if(k[e.key]) move(k[e.key]);
    };

    const setupBtn = (id, dir) => {
        const el = document.getElementById(id);
        el.addEventListener('touchstart', (e) => { e.preventDefault(); move(dir); });
        el.addEventListener('mousedown', (e) => { move(dir); });
    };
    setupBtn('m-up', 'forward'); setupBtn('m-down', 'backward');
    setupBtn('m-left', 'left'); setupBtn('m-right', 'right');

    function init() {
        for(let i=0; i>-5; i--) {
            const g = new THREE.Mesh(new THREE.BoxGeometry(1200,tileSize,2), new THREE.MeshLambertMaterial({color:0xbaf455}));
            g.position.y = i * tileSize; map.add(g);
        }
        addRows(30); buildPlayer(); animate();
    }
    init();
</script>
</body>
</html>
