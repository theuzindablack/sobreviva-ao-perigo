<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Capivara Crossy Road</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Arial Black', sans-serif; background-color: #8BC34A; }
        canvas.game { display: block; }

        #score {
            position: absolute; top: 30px; width: 100%; text-align: center;
            font-size: 80px; font-weight: 900; color: white;
            text-shadow: 4px 4px 0px rgba(0,0,0,0.3); pointer-events: none; z-index: 10;
        }

        #controls {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; align-items: center; gap: 15px; z-index: 10;
        }
        .button-row { display: flex; gap: 15px; }
        #controls button {
            width: 70px; height: 70px; font-size: 24px; cursor: pointer;
            background: #fff; border: none; border-radius: 20px;
            box-shadow: 0 8px 0px #bbb; transition: 0.1s;
        }
        #controls button:active { transform: translateY(4px); box-shadow: 0 4px 0px #999; }

        #result-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(5px);
            display: flex; align-items: center; justify-content: center;
            visibility: hidden; opacity: 0; transition: 0.4s; z-index: 100;
        }
        #result-container.visible { visibility: visible; opacity: 1; }
        #result { background: white; padding: 40px; text-align: center; border-radius: 30px; }
    </style>
</head>
<body>

<div id="score">0</div>
<canvas class="game"></canvas>

<div id="controls">
    <button id="forward">▲</button>
    <div class="button-row">
        <button id="left">◀</button>
        <button id="backward">▼</button>
        <button id="right">▶</button>
    </div>
</div>

<div id="result-container"><div id="result">
    <h1 style="color:#795548; margin:0">OPS!</h1>
    <span id="final-score" style="font-size:80px; font-weight:900;">0</span>
    <p>A capivara foi atropelada!</p>
</div></div>

<script type="module">
    import * as THREE from "https://esm.sh/three";

    const tileSize = 42;
    const minTile = -6;
    const maxTile = 6;
    let isGameOver = false, metadata = [], movesQueue = [];
    let position = { row: 0, tile: 0 };

    const scene = new THREE.Scene();
    const map = new THREE.Group(); scene.add(map);
    const player = new THREE.Group(); scene.add(player);

    // --- MODELO: CAPIVARA ---
    function createCapybara() {
        const capy = new THREE.Group();
        const brownMat = new THREE.MeshLambertMaterial({ color: 0x795548 }); // Marrom principal
        const darkBrownMat = new THREE.MeshLambertMaterial({ color: 0x4e342e }); // Focinho e orelhas

        // Corpo
        const body = new THREE.Mesh(new THREE.BoxGeometry(22, 30, 18), brownMat);
        body.position.z = 12; body.castShadow = true; capy.add(body);

        // Cabeça
        const head = new THREE.Mesh(new THREE.BoxGeometry(16, 12, 14), brownMat);
        head.position.set(0, 18, 16); head.castShadow = true; capy.add(head);

        // Focinho (clássico da capivara)
        const snout = new THREE.Mesh(new THREE.BoxGeometry(16, 6, 10), darkBrownMat);
        snout.position.set(0, 22, 14); capy.add(snout);

        // Patas
        const legGeo = new THREE.BoxGeometry(6, 6, 8);
        [[-8, 10], [8, 10], [-8, -10], [8, -10]].forEach(p => {
            const leg = new THREE.Mesh(legGeo, brownMat);
            leg.position.set(p[0], p[1], 4); capy.add(leg);
        });

        // Orelhas
        const earGeo = new THREE.BoxGeometry(4, 2, 4);
        const earL = new THREE.Mesh(earGeo, darkBrownMat); earL.position.set(6, 15, 23); capy.add(earL);
        const earR = new THREE.Mesh(earGeo, darkBrownMat); earR.position.set(-6, 15, 23); capy.add(earR);

        return capy;
    }

    const capyModel = createCapybara();
    player.add(capyModel);

    // Luzes e Câmera
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(-50, -100, 200); dirLight.castShadow = true;
    scene.add(dirLight);

    const camera = new THREE.OrthographicCamera();
    camera.up.set(0, 0, 1);
    camera.position.set(300, -300, 300);

    const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector(".game"), antialias: true });
    renderer.shadowMap.enabled = true;
    renderer.setClearColor(0x8BC34A);

    function resize() {
        const ratio = window.innerWidth / window.innerHeight;
        const size = 180;
        camera.left = -size * ratio; camera.right = size * ratio;
        camera.top = size; camera.bottom = -size;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', resize); resize();

    // Modelos de Ambiente
    function createTree(tile) {
        const g = new THREE.Group(); g.position.x = tile * tileSize;
        const trunk = new THREE.Mesh(new THREE.BoxGeometry(10, 10, 15), new THREE.MeshLambertMaterial({ color: 0x5D4037 }));
        trunk.position.z = 7.5; g.add(trunk);
        const crown = new THREE.Mesh(new THREE.BoxGeometry(25, 25, 30), new THREE.MeshLambertMaterial({ color: 0x388E3C }));
        crown.position.z = 30; crown.castShadow = true; g.add(crown);
        return g;
    }

    function createCar(dir) {
        const car = new THREE.Group();
        const color = [0xFF5252, 0xFFC107, 0x03A9F4][Math.floor(Math.random()*3)];
        const body = new THREE.Mesh(new THREE.BoxGeometry(65, 32, 20), new THREE.MeshLambertMaterial({ color }));
        body.position.z = 10; body.castShadow = true; car.add(body);
        const roof = new THREE.Mesh(new THREE.BoxGeometry(35, 28, 12), new THREE.MeshLambertMaterial({ color: 0x333333 }));
        roof.position.set(-5, 0, 25); car.add(roof);
        if(!dir) car.rotation.z = Math.PI;
        return car;
    }

    function addRows(n) {
        for(let i=0; i<n; i++) {
            const rowIdx = metadata.length + 1;
            const isRoad = Math.random() > 0.5;
            const row = new THREE.Group(); row.position.y = rowIdx * tileSize;
            let data = { type: isRoad?"road":"grass", vehicles: [], trees: [] };

            if(isRoad) {
                const r = new THREE.Mesh(new THREE.PlaneGeometry(1000, tileSize), new THREE.MeshLambertMaterial({color:0x424242}));
                r.receiveShadow = true; row.add(r);
                data.dir = Math.random() > 0.5; data.speed = 130 + Math.random()*100;
                const v = createCar(data.dir); row.add(v); data.vehicles.push({ ref: v });
            } else {
                const g = new THREE.Mesh(new THREE.BoxGeometry(1000, tileSize, 2), new THREE.MeshLambertMaterial({color:0x8BC34A}));
                g.receiveShadow = true; row.add(g);
                for(let t=0; t<3; t++) {
                    const tIdx = Math.floor(Math.random()*(maxTile-minTile)) + minTile;
                    if(tIdx !== 0 || rowIdx > 1) { row.add(createTree(tIdx)); data.trees.push(tIdx); }
                }
            }
            metadata.push(data); map.add(row);
        }
    }

    function move(d) {
        if(isGameOver || movesQueue.length > 0) return;
        let tRow = position.row + (d==="forward"?1:d==="backward"?-1:0);
        let tTile = position.tile + (d==="right"?1:d==="left"?-1:0);
        if(tRow < 0 || tTile < minTile || tTile > maxTile) return;
        if(metadata[tRow-1]?.type === "grass" && metadata[tRow-1].trees.includes(tTile)) return;
        movesQueue.push({ dir: d, tX: tTile * tileSize, tY: tRow * tileSize, progress: 0 });
    }

    function init() {
        isGameOver = false; metadata = []; map.clear();
        for(let i=0; i>-5; i--) {
            const g = new THREE.Mesh(new THREE.BoxGeometry(1000,tileSize,2), new THREE.MeshLambertMaterial({color:0x8BC34A}));
            g.position.y = i * tileSize; map.add(g);
        }
        addRows(25); position = { row: 0, tile: 0 };
        player.position.set(0,0,0);
        document.getElementById("score").innerText = "0";
        document.getElementById("result-container").classList.remove("visible");
    }

    function animate() {
        requestAnimationFrame(animate);
        if(!isGameOver) {
            metadata.forEach(r => {
                r.vehicles?.forEach(v => {
                    v.ref.position.x += (r.dir?1:-1) * r.speed * 0.016;
                    if(v.ref.position.x > 500) v.ref.position.x = -500;
                    if(v.ref.position.x < -500) v.ref.position.x = 500;
                });
            });

            if(movesQueue.length > 0) {
                const m = movesQueue[0];
                m.progress += 0.2;
                player.position.x = THREE.MathUtils.lerp(position.tile * tileSize, m.tX, m.progress);
                player.position.y = THREE.MathUtils.lerp(position.row * tileSize, m.tY, m.progress);
                capyModel.position.z = Math.sin(m.progress * Math.PI) * 12;

                // Rotação da capivara
                if(m.dir === "left") capyModel.rotation.z = Math.PI/2;
                else if(m.dir === "right") capyModel.rotation.z = -Math.PI/2;
                else if(m.dir === "forward") capyModel.rotation.z = 0;
                else if(m.dir === "backward") capyModel.rotation.z = Math.PI;

                if(m.progress >= 1) {
                    player.position.set(m.tX, m.tY, 0);
                    position.row += (m.dir==="forward"?1:m.dir==="backward"?-1:0);
                    position.tile += (m.dir==="right"?1:m.dir==="left"?-1:0);
                    movesQueue.shift();
                    document.getElementById("score").innerText = position.row;
                    if(position.row > metadata.length - 12) addRows(10);
                }
            }

            const curR = metadata[position.row - 1];
            if(curR?.type === "road") {
                curR.vehicles.forEach(v => {
                    if(Math.abs(v.ref.position.x - player.position.x) < 40) {
                        isGameOver = true;
                        document.getElementById("final-score").innerText = position.row;
                        document.getElementById("result-container").classList.add("visible");
                        setTimeout(init, 3000);
                    }
                });
            }
        }
        camera.position.y = player.position.y - 250;
        camera.position.x = player.position.x + 250;
        camera.lookAt(player.position.x, player.position.y, 0);
        renderer.render(scene, camera);
    }

    const setupBtn = (id, d) => document.getElementById(id).onclick = () => move(d);
    setupBtn("forward", "forward"); setupBtn("backward", "backward");
    setupBtn("left", "left"); setupBtn("right", "right");
    window.onkeydown = (e) => {
        const k = { ArrowUp:"forward", ArrowDown:"backward", ArrowLeft:"left", ArrowRight:"right" };
        if(k[e.key]) move(k[e.key]);
    };

    init(); animate();
</script>
</body>
</html>
